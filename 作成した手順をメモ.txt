【laravel6のインストール】
//最新版が良ければバージョンの指定は無くてOK
composer create-project "laravel/laravel=6.*" プロジェクト名 --prefer-dist

【認証機能追加】
//これでuiの機能がインストールされる感じ？
composer require laravel/ui="1.*" --dev

//下記のbootstrap --authを実行するなら不要かも
php artisan ui vue --auth

【これすると上記で作成されたファイルを置き換えるようなので、これだけでいいのかも？】
php artisan ui bootstrap
php artisan ui bootstrap --auth

【脆弱性を全修正する】（使わなかった）
npm audit fix --force

「Error: error:0308010C:digital envelope routines::unsupported」というエラーが発生。
ググって出てきたstack overflowに記載のあった「set NODE_OPTIONS=--openssl-legacy-provider」する事対処。

DBにsqliteを使用する為、.envとconfig/database.phpを修正。
DB_CONNECTIONの項目をsqliteに変更する。

ここらでサーバを立ち上げて動作確認、welcomeページが表示されてて、認証機能のリンクが表示されてればOKかな。

【ModelとMigrationファイルを作成】
php artisan make:model モデル名 -m
-mのオプションを付けるとMigrationファイルも合わせて作成される。

【-a オプション】
php artisan make:model モデル名 -a
-aオプションを付けると、migration, seeder, factory, resource controllerも作成したModelに合わせて用意してくれる。
Model名は単数形の名前、テーブル名は複数形の名前である必要があるところも、自動でやってくれちゃう！

【Seederファイルの作成】
php artisan make:seed シーダーファイル名

    "基本的にシーダーファイルにはデータベースに情報を挿入するための
    ■Eloquant
    ■DBファサード
    あたりのどれかが必要となってきます。"

ファサードを使う場合
use Illuminate\Support\Facades\DB; //追記する

Seederを実行する前に、SeederフォルダにあるDatabaseSeeder.phpに
作成したSeederファイルを記述する必要がある。

【オートロードを使用出来るようにする？】
Laravelフォルダ上で下記を実行する
    composer dump-autoload
"シーダー機能はPHPのオートロード（つまりはcomposerを使う）を利用しますので上記コマンドが必要となります。"

【Seederファイルを作成】
    use App\Models\モデル名;
        DB::table('テーブル名')->truncate(); //2回目実行の際にシーダー情報をクリア
        モデル名::create([
            'user_id' => 1,
            'thing' => Str::random(20),
        ]);

【シーディングを実行】
php artisan db:seed

【ルーティングの設定】（web.php）
コントローラを用いるため、Route::get('アドレス', 'コントローラ@アクション名');という要領で、
Route::get('/', 'ShopController@index');等とする。

【Laravel8以降のルーティングの書き方】
一覧画面の表示
    Route::get('/', [BookController::class, 'index'])->name('book.index');
本の登録画面の表示
    Route::get('/create', [BookController::class, 'create'])->name('book.create');
本の登録処理
    Route::post('/store', [BookController::class, 'store'])->name('book.store');
本の詳細
    Route::get('/show/{id}', [BookController::class, 'show'])->name('book.show');
本の編集画面
    Route::get('/edit/{id}', [BookController::class, 'edit'])->name('book.edit');
本の更新処理
    Route::post('/update/{id}', [BookController::class, 'update'])->name('book.update');
本の削除
    Route::post('/destroy{id}', [BookController::class, 'destroy'])->name('book.destroy');

->name(‘book.index’)のように書くと、ルート名に名前をつけられます。
例えば、ビューで以下のように呼び出すことができ、リンクをクリックするとURLの/に遷移します。

    <a href="{{ route('book.index') }}>一覧画面へ</a>

【Resourcefulなメモ】
/コントローラ               |index
/コントローラ/create        |create
/コントローラ               |store（POST送信）
/コントローラ/番号          |show（番号=id）
/コントローラ/番号/edit     |edit（番号=id）
/コントローラ/番号          |update（番号=id、PUT/PATCH送信）
/コントローラ/番号          |delete（番号=id、DELETE送信）

【ルーティング一覧を見るコマンド】
    php artisan route:list

【コントローラの作成】
    php artisan make:controller コントローラ名 --resource

【一連の流れ】
この流れの作成順は、自分なりに分かりやすい順番で作った方がいいかも知れん。

    http://localhost/にアクセス
    ↓
    web.phpでルーティング（指定したアドレスにアクセスした時に、どんなアクションをさせるか設定）
    ↓
    ShopControllerのindexメソッドを発動（コントローラにページを表示させる記述）
    ↓
    上記の通りreturnでshop.blade.phpを返す処理（bladeの表示）

と言う一連の流れが出来上がりました。

【アプリケーションの全キャッシュ削除】
php artisan cache:clear

【Modelの作成】
Modelの作成のコマンドに「--m」でMigrationファイルをまとめて作成できるから、
Modelの作成はもっと早くても良いような。

php artisan make:model Models/Stock

これで、Modelsフォルダ内にStockモデルが作成される。
このStock.phpはどこにも実際のデータベースのStocksテーブルと結び付ける記述がどこにもありません。

けどLaravelの命名規則で、Modelのクラス名を単数形で指定して、
テーブル名を複数形にするというのがあるので、それを満たしておけば勝手にLaravelが判断して結びつけてくれます。
今回だと「Stock」モデルと「Stocks」テーブル。
他にも「Person」モデルと「People」テーブル。

protected $table = 'test_table';
などを追記すればそのモデル名とは関係ないテーブルと紐付けも可能です。

protected $guarded = ['id'];（idカラムを保護する）
protected $fillable = ['id'];（idカラムを編集可能にする）

ログインしている人だけに表示させたい！
middlewareのauthを使用するだけで実現出来る

    ->middleware('auth')（ルート情報にミドルウェアを使用する記述を行う）

Route::get('/mycart', 'ShopController@myCart')->middleware('auth');

カートに商品を追加
カートに入れるボタンを<form>で作成、actionにはカートに入れる処理のアドレスを記述する

    <form action="mycart" method="post">
        @csrf
        <input type="hidden" name="stock_id" value="{{ $stock->id }}">
        <input type="submit" value="カートに入れる" class="btn btn-primary">
    </form>

"ちなみにGET送信とPOST送信の違いがわからない方は、
・GET送信→普通にアクセス
・POST送信→formを経由してのアクセス
くらいの認識で今は十分かなと思います。"

【cssを書く場所】
/resources/sassフォルダに、_style.scssファイルを作成、ここにcssを書く。
同フォルダのapp.scss内に@import 'style';を追記する事で、cssを読み込むようになる。

    "ですが、このままだと反映されません。
    scss(sass)ファイルはコンパイルしてcssに変換してあげる必要があります。
    Laravelにはlaravel Mixというビルドツールが最初から入っているので
    ターミナルから「npm run dev」を実行する事で反映されるようになる"

今回は「npm run dev」でエラーが出るので、レイアウトの<head>に書く事にした。

【public function myCart(Cart $cart)この引数何なん？】
    "メソッドインジェクションです。
    俗に言うDI(依存性注入)の方法の一つですね。
    名前かっこいいですが、でやってくれているのは、
    $cart = new Cart();
    という通常のインスタンス化の記述を不要にしてくれてるくらい"

【変数が空の場合は空文字とする】
    例えば$messageが空の変数だとして、
    {{ $message ?? '' }}
    とすることで、変数の値が空の場合は空文字にする、という事になる。
    $messageのデフォルト値を設定している事になるみたい。

【Modelに書くべき処理とは】
    コントローラが肥大化しすぎないように、DBに関係する処理はModelに書くみたいな感じ。

【コレクションとは？】
    コレクション(collection)はLaravel独自の形式で配列を操作する機能が拡張されたラッパークラスです。
    使い方は簡単で配列をコレクション形式に変換後、定義されているメソットを呼び出すことで
    様々な操作や機能を簡単に実装することができます。
    またEloquent(エロクアント)の返り値は自動的にコレクション配列に変換されます。

【アロー（->）とダブコロ（::）】
クラスをインスタンス化したもの（newしたもの）のメソッドを呼び出すときは「->」、
クラスのメソッドをstaticに呼び出すとき（staticなメソッドを呼び出すとき、つまり、newする必要がないとき）は「::」を使います。

【Mailの返信】
このコマンドで…
    php artisan make:mail Thanks --markdown="mails.thanks"

以下のファイルが作成される
    app/Mails/Thanks.php
    resources/views/mails/thanks.blade.php

それぞれ、メールの送信機能と、メール内容の本文になる

【デバッグバーを導入しよう】
ターミナルでコマンドを実行。
composer require barryvdh/laravel-debugbar

envファイルで下記のようにtrueにする。
APP_DEBUG=true

composer.jsonにデバッグバーの記述が書かれていればOK

デバッグバーにメッセージを表示させる
\Debugbar::info($things); // コントローラ等に書いて使う

参考サイト
https://migisanblog.com/laravel-debugbar-install/

【batファイルでローカルサーバを起動させる方法】
バッチファイルに以下を記述する
    @echo off
    cd C:\Laravel_Dir\koto_koto (Laravel作業フォルダ)
    cmd /k php artisan serve (コマンドプロンプトで実行するコマンド cmdだけにするとコマンドプロンプトが起動するだけになる)

【Xdebugの導入】
php -i | clip (クリップボードにphpinfoの情報をコピー)

Xdebugのサイトでphpinfo()の情報を入力する
https://xdebug.org/wizard

出てきたdllファイルをダウンロードしリネーム、指定されたフォルダに配置php.iniに以下を追記する
    [Xdebug]
    zend_extension="C:\xampp\php\ext\php_xdebug.dll"
    xdebug.mode=debug
    xdebug.start_with_request=yes
    xdebug.client_host=127.0.0.1
    xdebug.client_port =9003

VScodeの「実行とデバッグ」で作成したlaunch.jsonには以下の記述が必要
    {
        "name": "Listen for Xdebug",
        "type": "php",
        "request": "launch",
        "port": 9003
    },

サーバを再起動し、phpinfo()を確認。
Xdebugの項目が表示されていれば、導入完了。

【GitHubからローカル環境へcloneする】
クローンを作成したい場所で以下のコマンドを実行する

    git clone https://github.com/<user-name>/<repository-name>.git

GitHubのリモートリポジトリからcloneのコマンドをコピーする事も出来る
ローカルの端末でGitの設定を終わらせていれば、これだけでプッシュも出来るようになる。

【VS Codeの拡張機能を一覧表示するコマンド】
C:\Users\user>code --list-extensions
// 以下、実行内容
8amjp.charactercount
amiralizadeh9480.laravel-extra-intellisense
bmewburn.vscode-intelephense-client
bradgashler.htmltagwrap
christian-kohler.path-intellisense
donjayamanne.githistory
ecmel.vscode-html-css
formulahendry.auto-rename-tag
glenn2223.live-sass
mosapride.zenkaku
mrmlnc.vscode-autoprefixer
MS-CEINTL.vscode-language-pack-ja
oderwat.indent-rainbow
onecentlin.laravel-blade
onecentlin.laravel5-snippets
pranaygp.vscode-css-peek
sdras.night-owl
shufo.vscode-blade-formatter
sibiraj-s.vscode-scss-formatter
streetsidesoftware.code-spell-checker
vscode-icons-team.vscode-icons
xabikos.JavaScriptSnippets
xdebug.php-debug